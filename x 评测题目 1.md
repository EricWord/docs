```java
//评测题目: 
1. 多线程题目：单例队列容器消费
实现一个单例队列容器，提供三个方法 offer，poll，size
写三个线程，
   线程1将字符串a挨个添加到容器中，
   线程2将字符串b挨个添加到容器中，
   线程1与线程2同时启动后交替执行
   线程3监听容器变化，调用poll每隔1s挨个输出
示例：
输入：a = "hloaiaa", b = "el,lbb"
输出：hello,alibaba

import java.util.LinkedList;
import java.util.concurrent.Semaphore;
import java.util.concurrent.atomic.AtomicInteger;

public class Test {

    private Test(int maxSize) {

        this.maxSize = maxSize;
    }

    static Semaphore one = new Semaphore(1);
    static Semaphore two = new Semaphore(0);
//    static Semaphore monitor = new Semaphore(0);

    private static LinkedList<Character> singletonQueue = new LinkedList<Character>();
    static String a = "hloaiaa";
    static String b = "el,lbb";
    private static AtomicInteger count = new AtomicInteger(0);

    private static int maxSize = 100;

    private static final Object lock = new Object();

    public static void offer(char s) {
        synchronized (lock) {
            while (count.get() == maxSize) {
                try {
                    lock.wait();
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
            }
            singletonQueue.add(s);
            count.getAndIncrement();
//            System.out.println(" 元素 " + s + " 被添加 " + "length=" + count.get());
            lock.notify();

        }
    }

    public static Character poll() {
        Character temp = null;
        synchronized (lock) {
            int minSize = 0;
            while (count.get() == minSize) {
                try {
                    lock.wait();
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
            }
            count.getAndDecrement();
            temp = singletonQueue.poll();
//            System.out.println(" 元素 " + temp + " 被消费 ");
            lock.notify();
        }
        return temp;
    }

    public static int size() {
        return count.get();
    }


    public static void main(String[] args) {
//        offer('a');
//        System.out.println(poll());
//    }
        Runnable r1 = new Runnable() {

            @Override
            public void run() {
                char[] as = a.toCharArray();
                for (char c : as) {
//                System.out.println(c);
                    try {
                        one.acquire();
                        offer(c);
                        two.release();
//                        monitor.release();

                    } catch (InterruptedException e) {
                        e.printStackTrace();
                    }


                }

            }
        };
        Runnable r2 = new Runnable() {

            @Override
            public void run() {
                char[] bs = Test.b.toCharArray();
                for (char c : bs) {
                    try {
                        two.acquire();
                        offer(c);
                        one.release();
//                        monitor.release();

                    } catch (InterruptedException e) {
                        e.printStackTrace();
                    }


                }

            }
        };
        Runnable r3 = new Runnable() {

            @Override
            public void run() {
                while (true) {
                    if (count.get() > 0) {
                        System.out.print(poll());
//                        try {
////                            Thread.sleep(1000);
//                        } catch (InterruptedException e) {
//                            e.printStackTrace();
//                        }

                    }
                }


            }
        };
        new Thread(r1).start();
        new Thread(r2).start();
        new Thread(r3).start();

    }


}









2.单词统计
给定一个字符串，计算字符串中每个单词出现的数量，并排序输出。
a. 单词一个大写字母开始，接着跟随0个或任意个小写字母；
b. 如果单词数量大于 1，单词后会跟着数字表示单词的数量。如果数量等于 1 则不会跟数字。例如，Hello2World 和 是合法，但 Hello1World2 这个表达是不合法的；
c. Hello2表示HelloHello；
d.  (Hello2World2)3 可以等于Hello2World2Hello2World2Hello2World2；
输出格式为：第一个（按字典序）单词，跟着它的数量（如果单词数量为1，则不输出），然后是第二个单词的名字（按字典序），跟着它的数量（如果单词数量为1，则不输出），以此类推。
示例1：
输入：字符串 = "World3Hello"
输出: "HelloWorld3"
解释: 单词数量是 {'Hello': 1, 'World': 3}。
示例 2:
输入: 字符串 = "Welcome4(ToAlibaba(To3)2)2"
输出: "Alibaba2To14Welcome4"
解释: 单词数量是 {'Alibaba': 2, 'To': 14', Welcome': 4,}。
注意:
字符串的长度在[1, 100000]之间。
字符串只包含字母、数字和圆括号，并且题目中给定的都是合法的字符串。


import java.util.*;

public class Solution {
    public String wordCount(String str) {
        StringBuilder ans = new StringBuilder();
        Map<String, String> map = new LinkedHashMap<>();
        //包含括号的情况
        if (str.contains("(")) {
          //按照括号进行分割
          //然后将数字更新成最终的数字


        } else {
            //不包含括号的情况
            char[] array = str.toCharArray();
            int tempIndex = 0;
            for (int i = 0; i < array.length; ) {
                //是数字
                if (!((array[i] >= 'A' && array[i] <= 'Z') || (array[i] >= 'a' && array[i] <= 'z'))) {
                    tempIndex = i;
                    //下一个是不是数字，针对两位数字的情况
                    StringBuilder tmp = new StringBuilder();
                    StringBuilder ss = new StringBuilder();
                    for (int j = 0; j < i; j++) {
                        ss.append(array[j]);
                    }
//                    map.put(ss.toString(), "");
                    while (!(array[i] >= 'A' && array[i] <= 'Z' || array[i] >= 'a' && array[i] <= 'z')) {
                        tmp.append(array[i]);
                        array[i] = ' ';
                        i++;
                    }
                    map.put(ss.toString(), tmp.toString());


                }
                i++;
            }
            if ((array[array.length - 1] >= 'A' && array[array.length - 1] <= 'Z') || (array[array.length - 1] >= 'a' && array[array.length - 1] <= 'z')) {
                //最后一个特殊处理
                StringBuilder sss = new StringBuilder();
                for (int m = tempIndex; m < array.length; m++) {
                    sss.append(array[m]);
                }
                map.put(sss.toString(), "1");
            }
            Map<String, String> newMap = sortMapByValue(map);
            for (Map.Entry<String, String> entry : newMap.entrySet()) {
                String mapKey = entry.getKey();
                String mapValue = entry.getValue();
                ans.append(mapKey);
                if (!mapValue.equals("1")) {
                    ans.append(mapValue);
                }
            }

        }


        return ans.toString().replace(" ", "");
    }

    public static void main(String[] args) {
        Solution solution = new Solution();
        System.out.println(solution.wordCount("World3Hello"));
    }

    public static Map<String, String> sortMapByValue(Map<String, String> oriMap) {

        if (oriMap == null || oriMap.isEmpty()) {

            return null;

        }

        Map<String, String> sortedMap = new LinkedHashMap<String, String>();

        List<Map.Entry<String, String>> entryList = new ArrayList<Map.Entry<String, String>>(

                oriMap.entrySet());

        Collections.sort(entryList, new MapValueComparator());


        Iterator<Map.Entry<String, String>> iter = entryList.iterator();

        Map.Entry<String, String> tmpEntry = null;

        while (iter.hasNext()) {

            tmpEntry = iter.next();

            sortedMap.put(tmpEntry.getKey(), tmpEntry.getValue());

        }

        return sortedMap;

    }

    static class MapValueComparator implements Comparator<Map.Entry<String, String>> {


        @Override
        public int compare(Map.Entry<String, String> o1, Map.Entry<String, String> o2) {
            return o2.getValue().compareTo(o1.getValue());
        }
    }

}



3. 题目：贴墙纸（选做）
你是一位装修工，根据设计师的要求给客户的客厅背景墙贴墙纸。
假设背景墙面积为 n x m，装修风格为现代极简风格，需要使用尽可能少的 不同颜色的 正方形 墙纸包 来铺满墙面。
假设正方形墙纸包块的规格不限，边长都是整数。
请你帮设计师计算一下，最少需要用到多少块方形墙纸包？
示例 1：
输入：n = 2, m = 3
输出：3
解释：3 块墙纸包就可以铺满墙面。
2 块 1x1 墙纸包
1 块 2x2 墙纸包
示例 2：
输入：n = 5, m = 8
输出：5
示例 3：
输入：n = 11, m = 13
输出：6
提示：
1 <= n <= 13
1 <= m <= 13
答案：
1、统一为高>宽的长方形
2、从左下角开始，计算当前最低填充高度，填充正方形。
3、填充完毕，比较最小步数
```

