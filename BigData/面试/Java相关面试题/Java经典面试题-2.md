[TOC]

# 1. 对volatile的理解

volatile是Java虚拟机提供的轻量级的同步机制

## 1.1 三大特性

### 1.1.1 保证可见性





### 1.1.2 不保证原子性



### 1.1.3 禁止指令重排





## 1.2 JMM内存模型之可见性

![image-20210519154531583](images/image-20210519154531583.png)

![image-20210519154755463](images/image-20210519154755463.png)

![image-20210519161335715](images/image-20210519161335715.png)

![image-20210519164218610](images/image-20210519164218610.png)

![image-20210519164522812](images/image-20210519164522812.png)

![image-20210519164804012](images/image-20210519164804012.png)

![image-20210519165136519](images/image-20210519165136519.png)

### 1.2.1 禁止指令重排小总结

![image-20210519165657729](images/image-20210519165657729.png)

![image-20210519165907114](images/image-20210519165907114.png)

![image-20210519170042322](images/image-20210519170042322.png)

## 1.3 volatile的应用场景

![image-20210519194426318](images/image-20210519194426318.png)

![image-20210519194954965](images/image-20210519194954965.png)





# 2. CAS

## 2.1 CAS是什么？

比较并交换

![image-20210519201703838](images/image-20210519201703838.png)

![image-20210519201923436](images/image-20210519201923436.png)

![image-20210519201941774](images/image-20210519201941774.png)

![image-20210519202538496](images/image-20210519202538496.png)

![image-20210519202748544](images/image-20210519202748544.png)

![image-20210519203042103](images/image-20210519203042103.png)





## 2.2 CAS的底层原理

面试题:CAS的底层原理？如果知道，谈谈你对UnSafe的理解



底层原理：自旋锁 UnSafe



![image-20210519201332643](images/image-20210519201332643.png)

![image-20210519201501941](images/image-20210519201501941.png)

![image-20210519201620744](images/image-20210519201620744.png)

![image-20210519203212003](images/image-20210519203212003.png)



## 2.3 小总结

![image-20210519203313346](images/image-20210519203313346.png)



## 2.4 CAS的缺点

![image-20210519203524223](images/image-20210519203524223.png)

![image-20210519203554229](images/image-20210519203554229.png)

![image-20210519203714385](images/image-20210519203714385.png)





# 3. ABA问题

面试题:原子类AtomicInteger的ABA问题谈谈？原子更新引用知道嘛？



## 3.1 什么是ABA问题？

狸猫换太子

![image-20210519204616777](images/image-20210519204616777.png)



## 3.2 原子引用

![image-20210519205305052](images/image-20210519205305052.png)

## 3.3 时间戳原子引用

![image-20210519205724642](images/image-20210519205724642.png)

使用时间戳原子引用可以解决ABA问题



# 4. 集合类不安全之并发修改异常

面试题:我们知道ArrayList是线程不安全，请编码写一个不安全的案例并给出解决方案



![image-20210520100442217](images/image-20210520100442217.png)

![image-20210520100245616](images/image-20210520100245616.png)



# 5. 集合类不安全之set

![image-20210520101046858](images/image-20210520101046858.png)

注意HashSet底层是HashMap,add时其实是添加到HashMap中的key,而value都是一个名称为present的Object常量



# 6. 集合类不安全之Map

![image-20210520101419042](images/image-20210520101419042.png)



# 7. 锁之公平和非公平锁

![image-20210520102556825](images/image-20210520102556825.png)

## 7.1 公平和非公平锁

### 7.1.1 是什么？

![image-20210520103004259](images/image-20210520103004259.png)

### 7.1.2 两者区别

![image-20210520103534188](images/image-20210520103534188.png)

### 7.1.3 题外话

![image-20210520103744208](images/image-20210520103744208.png)



## 7.2 可重入锁(又名递归锁)

![image-20210520104050825](images/image-20210520104050825.png)

### 7.2.1 是什么？

![image-20210520104209926](images/image-20210520104209926.png)





### 7.2.2 ReentrantLock/Synchronized





### 7.2.3 作用

最大的作用就是避免死锁





### 7.2.4 ReenterLockDemo





## 7.3 自旋锁



### 7.3.1 理论

![image-20210520110852056](images/image-20210520110852056.png)

### 7.3.2 手写一个自旋锁

![image-20210520112345492](images/image-20210520112345492.png)



## 7.4 读写锁

### 7.4.1 理论

![image-20210520112806160](images/image-20210520112806160.png)





# 8. CountDownLatch

![image-20210520123749866](images/image-20210520123749866.png)

![image-20210520142020800](images/image-20210520142020800.png)



# 9.CyclicBarrier

![image-20210520142157070](images/image-20210520142157070.png)

# 10. Semaphore

![image-20210520142749241](images/image-20210520142749241.png)

![image-20210520143235400](images/image-20210520143235400.png)



# 11. 阻塞队列

![image-20210520143355836](images/image-20210520143355836.png)

## 11.1 队列+阻塞队列

![image-20210520143801896](images/image-20210520143801896.png)

![image-20210520143838152](images/image-20210520143838152.png)

![image-20210520143957208](images/image-20210520143957208.png)



## 11.2 好处

![image-20210520144122806](images/image-20210520144122806.png)

## 11.3 BlockingQueue的核心方法

![image-20210520145341325](images/image-20210520145341325.png)

![image-20210520145400382](images/image-20210520145400382.png)

![image-20210520150133741](images/image-20210520150133741.png)







## 11.4 架构梳理+种类分析

### 11.4.1 架构介绍

![image-20210520144748479](images/image-20210520144748479.png)

![image-20210520144757429](images/image-20210520144757429.png)

![image-20210520144808782](images/image-20210520144808782.png)

### 11.4.2 种类分析

![image-20210520144835105](images/image-20210520144835105.png)



### 11.4.3 SynchronousQueue

![image-20210520150510352](images/image-20210520150510352.png)

![image-20210520150841039](images/image-20210520150841039.png)



## 11.5 用在哪里

![image-20210520150917621](images/image-20210520150917621.png)



# 12. Synchronized和Lock有什么区别？

![image-20210520152409187](images/image-20210520152409187.png)

![image-20210520152607287](images/image-20210520152607287.png)

![image-20210520152736508](images/image-20210520152736508.png)

**注意第3点截图内容有误，ReentrantLock默认是非公平锁**



# 13. 线程池

## 13.1 为什么用线程池？优势是什么？

![image-20210520163610199](images/image-20210520163610199.png)

## 13.2 线程池如何使用(3种常用方式)

架构说明

![image-20210520164100482](images/image-20210520164100482.png)

![image-20210520164132954](images/image-20210520164132954.png)

![image-20210520164147938](images/image-20210520164147938.png)

![image-20210520164333626](images/image-20210520164333626.png)

![image-20210520164356472](images/image-20210520164356472.png)

 ![image-20210520165306861](images/image-20210520165306861.png)

![image-20210520165752928](images/image-20210520165752928.png)



![image-20210520165420295](images/image-20210520165420295.png)

![image-20210520165454038](images/image-20210520165454038.png)

![image-20210520165557257](images/image-20210520165557257.png)

## 13.3 线程池的几个重要参数介绍

![image-20210520165841843](images/image-20210520165841843.png)

![image-20210520170124052](images/image-20210520170124052.png)

![image-20210520170226451](images/image-20210520170226451.png)

![image-20210520170451643](images/image-20210520170451643.png)







## 13.4 说说线程池的底层工作原理



<img src="images/image-20210520205557846.png" alt="image-20210520205557846" style="zoom: 200%;" />

<img src="images/image-20210520171323947.png" alt="image-20210520171323947" style="zoom: 200%;" />



## 13.5 线程池的4种拒绝策略

### 13.5.1 是什么？

![image-20210520211341739](images/image-20210520211341739.png)

![image-20210520211440610](images/image-20210520211440610.png)

AnortPolicy(默认):直接抛出RejectedExecutionException异常阻止系统正常运行

CallerRunPolicy:"调用者运行"一种调节机制，该策略既不会抛弃任务，也不会抛出异常，而是将某些任务回退到调用者，从而降低新任务的流量

DiscardOldestPolicy:抛弃队列中等待最久的任务，然后把当前任务加入队列中尝试再次提交当前任务

DiscardPolicy:直接丢弃任务，不予任何处理也不抛出异常。如果允许任务丢失，这是最好的一种方案。





## 13.6 线程池实际工作中使用哪个？

面试题:black_nib::black_nib::black_nib::black_nib::black_nib::black_nib::black_nib:在工作中单一的/固定数的/可变的的三种创建线程池的方法，你用哪个？

答案是一个都不用，生产上只用自定义的



Executors中JDK已经给你提供了，为什么不用？

结合业务





## 13.7 线程池配置合理线程数

### 13.7.1 CPU密集型

![image-20210521095437270](images/image-20210521095437270.png)

### 13.7.2 IO密集型

第1种情况:

![image-20210521095608545](images/image-20210521095608545.png)

第2种情况:

![image-20210521095644604](images/image-20210521095644604.png)

# 14. 死锁编码及定位分析

## 14.1 是什么？

![image-20210521100103127](images/image-20210521100103127.png)

### 14.1.1 产生死锁的原因

1. 系统资源不足
2. 进程运行推进的顺序不合适
3. 资源分配不当

## 14.2 代码

![image-20210521101234581](images/image-20210521101234581.png)

## 14.3 解决

![image-20210521101251848](images/image-20210521101251848.png)

![image-20210521101334660](images/image-20210521101334660.png)



# 15. JVM-GC

## 15.1 复习

![image-20210521101735934](images/image-20210521101735934.png)

![image-20210521101811006](images/image-20210521101811006.png)

![image-20210521101931627](images/image-20210521101931627.png)

![image-20210521102005946](images/image-20210521102005946.png)

![image-20210521102035378](images/image-20210521102035378.png)

![image-20210521102057164](images/image-20210521102057164.png)

![image-20210521102223729](images/image-20210521102223729.png)

![image-20210521102235277](images/image-20210521102235277.png)

![image-20210521102506902](images/image-20210521102506902.png)

![image-20210521102544252](images/image-20210521102544252.png)

## 15.2 GCRoots

### 15.2.1 什么是垃圾

简单的说就是内存中已经不再使用到的空间就是垃圾

### 15.2.2 要进行垃圾回收，如何判断一个对象是否可以被回收？

1. 引用计数

   ![image-20210521103157677](images/image-20210521103157677.png)

   ![image-20210521103230577](images/image-20210521103230577.png)

2. 枚举根节点做可达性分析(根搜索路径)

   ![image-20210521103316938](images/image-20210521103316938.png)

   ![image-20210521103623527](images/image-20210521103623527.png)

**Java中可以作为GC Roots的对象**

![image-20210521105208863](images/image-20210521105208863.png)



## 15.3 JVM的标配参数和X参数



### 15.3.1 JVM的参数类型

1. 标配参数

   ![image-20210521110049580](images/image-20210521110049580.png)

   ![image-20210521110111368](images/image-20210521110111368.png)

   

   

2. X参数

   ![image-20210521110151123](images/image-20210521110151123.png)

   ![image-20210521110235534](images/image-20210521110235534.png)

   

3. XX参数

   ![image-20210521110322449](images/image-20210521110322449.png)

   

![image-20210521110347206](images/image-20210521110347206.png)

![image-20210521110442882](images/image-20210521110442882.png)

![image-20210521111055047](images/image-20210521111055047.png)

![image-20210521111207999](images/image-20210521111207999.png)

![image-20210521111221404](images/image-20210521111221404.png)

## 15.3 jinfo举例，如何查看当前运行程序的配置

![image-20210521111758706](images/image-20210521111758706.png)

![image-20210521111827571](images/image-20210521111827571.png)

![image-20210521111843515](images/image-20210521111843515.png)

![image-20210521112027645](images/image-20210521112027645.png)



## 15.4 坑题

![image-20210521112123238](images/image-20210521112123238.png)

![image-20210521112205932](images/image-20210521112205932.png)



## 15.5 查看JVM的默认值

![image-20210521112406337](images/image-20210521112406337.png)

![image-20210521112455345](images/image-20210521112455345.png)

![image-20210521112519458](images/image-20210521112519458.png)

![image-20210521113703246](images/image-20210521113703246.png)



## 15.6 堆内存初始大小复习

![image-20210521114936200](images/image-20210521114936200.png)

![image-20210521115007032](images/image-20210521115007032.png)

## 15.7 常用参数

![image-20210521121852117](images/image-20210521121852117.png)

![image-20210521121909090](images/image-20210521121909090.png)

![image-20210521121949096](images/image-20210521121949096.png)

![image-20210521122522171](images/image-20210521122522171.png)

![image-20210521122610141](images/image-20210521122610141.png)

注意，默认情况下元空间的大小只有20多M

![image-20210521122903800](images/image-20210521122903800.png)

## 15.8 常用基础参数SurvivorRatio

![image-20210521124928413](images/image-20210521124928413.png)

![image-20210521125000323](images/image-20210521125000323.png)

![image-20210521125142863](images/image-20210521125142863.png)

## 15.9 常用基础参数NewRatio

![image-20210521125631137](images/image-20210521125631137.png)

![image-20210521125811335](images/image-20210521125811335.png)

## 15.9 常用基础参数MaxTenuringThreshold

![image-20210521140548615](images/image-20210521140548615.png)



## 15.10 强引用

### 15.10.1 整体架构

![image-20210521141049439](images/image-20210521141049439.png)

### 15.10.2 是什么？

![image-20210521141214930](images/image-20210521141214930.png)



## 15.11 软引用

### 15.11.1 整体架构

![image-20210521141504458](images/image-20210521141504458.png)

### 15.11.2 是什么？

![image-20210521141551675](images/image-20210521141551675.png)





## 15.12 弱引用

### 15.12.1 整体架构

![image-20210521142210063](images/image-20210521142210063.png)

### 15.12.2 是什么？

![image-20210521142242708](images/image-20210521142242708.png)



## 15.13 软引用和弱引用的适用场景

![image-20210521142707181](images/image-20210521142707181.png)



## 15.14 虚引用

![image-20210521143720516](images/image-20210521143720516.png)

![image-20210521144051464](images/image-20210521144051464.png)

### 15.14.1 引用队列

![image-20210521144201419](images/image-20210521144201419.png)

![image-20210521144802587](images/image-20210521144802587.png)

## 15.15 GCRoots和四大引用小总结

![image-20210521145108021](images/image-20210521145108021.png)





## 15.16 常见OOM类型

![image-20210521154431458](images/image-20210521154431458.png)

![image-20210521155304623](images/image-20210521155304623.png)

![image-20210521160004991](images/image-20210521160004991.png)

![image-20210521160939897](images/image-20210521160939897.png)

![image-20210521161611330](images/image-20210521161611330.png)



## 15.17 垃圾回收器

### 15.17.1 垃圾回收算法和垃圾回收器的关系

GC算法是内存回收的方法论，垃圾收集器就是算法落地实现



### 15.17.2 垃圾回收器的分类

![image-20210521163531489](images/image-20210521163531489.png)

1. 串行垃圾回收器

   为单线程环境设计且只使用一个线程进行垃圾回收，会暂停所有的用户线程，所以不适合服务器环境

2. 并行垃圾回收器

   多个垃圾收集线程并行工作，此时用户线程是暂停的，适用于科学计算/大数据首台处理等弱交互场景

3. 并发垃圾回收器

   ![image-20210521165037160](images/image-20210521165037160.png)

   

4. G1垃圾回收器

   ![image-20210521165510156](images/image-20210521165510156.png)

   

![image-20210521165312876](images/image-20210521165312876.png)

