# Scala语法总结
## 1.Scala概述
### 1.1 Scala特点
一门以JAVA虚拟机(JVM)为运行环境并将面向对象和函数式编程的最佳特性结合在一起的静态类型编程语言  
+ 多范式(multi-paradigm)编程语言，支持面向对象和函数式编程
+ 源代码(.scala)会被编译成java字节码(.class)，然后运行于JVM之上，并可以调用现有的java类库，实现两种语言的无缝对接  
### 1.2 开发环境搭建
+ 官方安装包下载地址  
http://www.scala-lang.org/
### 1.3 Scala执行流程分析
![执行流程分析](./images/1-Scala执行流程分析.png)
### 1.4 注意事项
+ 源文件以".scala"为扩展名
+ 程序的执行入口是main()函数
+ 严格区分大小写
+ 方法由一条条语句构成，每个语句后不需要分号
+ 如果在同一行有多条语句，除了最后一条语句不需要分号，其他语句需要分号
### 1.5 输出的三种方式
+ 字符串通过+号连接(类似Java)  
```scala
val name = "xiaoming"
println("name=" + name + "age=" + age + " url=" + url)
```
+ printf用法，字符串通过%传值(类似C)
```scala
val age = 1
printf("age=%d\n",age)
```
+ 字符串通过$引用(类似PHP)
```scala
val url = "www.baidu.com"
println(s"url=$url")
```

## 2.变量
### 2.1 变量声明基本语法
var | val 变量名[:变量类型] = 变量值
### 2.2 注意事项
+ 声明变量时，类型可以省略(编译器自动推导，即类型推导)
+ 类型确定后，不能修改(scala是强类型的语言)
+ 在声明/定义一个变量时，可以使用var/val修饰,var修饰的变量可改变，val修饰的变量不可改变
+ val修饰的变量在编译后，等同于加上final
+ var修饰的对象引用可以改变，val修饰的则不可改变，但对象的状态(值)是可以改变的(比如自定义对象、数组、集合等)
+ 变量声明时，需要初始值
### 2.3 程序中+号的使用
+ 当左右两边都是数值型时，做加法运算
+ 当左右两边有一方是字符串，做拼接运算    
### 2.4 数据类型
+ Scala 与Java有相同的数据类型，在Scala中数据类型都是对象，也就是说Scala没有Java中的原生类型
+ Scala数据类型分为两大类：AnyVal(值类型)和AnyRef(引用类型)，注意：不管是AnyVal还是AnyRef都是对象
+ Scala数据类型体系一览表  
![数据类型体系一览表](./images/2-Scala数据类型一览表.png)
+ Scala数据类型列表  
![Scala数据类型列表](./images/3-Scala数据类型列表.png)
#### 2.4.1 整数类型
##### 2.4.1.1 使用细节
+ 各整数类型(Byte/Short/Int/Long)有固定的表示范围和字段长度,不受具体os的影响，以保证程序的可移植性
+ Scala的整型常量/字面量默认为Int类型，声明Long类型常量/字面量须后面加'l'或者'L'
+ Scala程序中变量声明为Int型，除非不足以表示大数，才使用Long
#### 2.4.2 浮点类型
##### 2.4.2.1 浮点类型的分类
![浮点类型的分类](./images/4-浮点类型的分类.png)
##### 2.4.2.2 使用细节
+ 与整数类型类似，浮点类型也有固定的表示范围和字段长度，不受具体os的影响
+ 浮点型常量默认为Double型,声明Float型常量，须在后面加'f'或者'F'
+ 浮点型常量的两种表示形式  
十进制数形式，例如：5.12 512.0f .512(必须有小数点)  
科学计数法形式，例如:5.12e2 = 5.12乘以10的2次方
+ 通常情况下应该使用Double类型，因为Double比Float型更精确
#### 2.4.3 字符类型
##### 2.4.3.1 基本介绍
字符类型可以表示单个字符，字符类型是Char，16位无符号Unicode字符(2个字节)，区间值为U+0000到U+FFFF
##### 2.4.3.2 使用细节
+ 字符常量是用单引号括起来的单个字符。例如：var c1='a'
+ Scala允许使用转义字符'\'来将其后的字符转变为特殊字符型常量。例如:var c3='\n'
+ 可以直接给Char赋一个整数，输出时会按照对应的unicode字符输出
+ Char类型是可以进行运算的，相当于一个整数，因为它们都有对应的Unicode编码
#### 2.4.4 布尔类型
##### 2.4.4.1 基本介绍
+ 布尔类型只允许取值true和false
+ 布尔类型占1个字节
+ 布尔类型适于逻辑运算，一般用于程序流程控制
#### 2.4.5 Unit/Null/Nothing类型
##### 2.4.5.1 基本说明
![三种类型的说明](./images/5-unit.png)
##### 2.4.5.2 使用细节和注意事项
+ Null类只有一个实例对象null,类似于Java中的null引用。null可以赋值给任意的引用类型(AnyRef),但是不能赋值给值类型(AnyVal:比如Int,Float,Char,Boolean,Long,Double,Byte,Short)
+ Unit类型用来标识过程，也就是没有明确返回值的函数。由此可见，Unit类似于Java中的void。Unit只有一个实例(),这个实例也没有实质的意义
+ Nothing,可以作为没有正常返回值的方法的返回类型，非常直观的说明这个方法不会正常返回，而且由于Nothing是其他任意类型的子类，它还能跟要求返回值的方法兼容
### 2.5 值类型转换
#### 2.5.1 值类型隐式转换
##### 2.5.1.1 基本介绍
Scala程序在进行赋值或运算时，精度小的类型自动转换为为精度大的数据类型  
数据类型按精度(容量)大小排序
![数据类型按精度(容量)大小排序](./images/6-隐式转换.png)
##### 2.5.1.2 自动类型转换细节说明
+ 有多种类型的数据混合运算时，系统首先自动将所有数据转换成容量最大的那种数据类型，然后再进行计算。例如: 5.6 + 10 > Double
+ 当我们把精度(容量)大的数据类型赋值给精度(容量)小的数据类型时会报错，反之会自动进行类型转换
+ (byte,short) 和 char之间不会相互自动转换
+ byte/short/char 三者可以计算，在计算时首先转换为int类型
+ 自动提升原则:表达式结果的类型自动提升为操作数中最大的类型
#### 2.5.2 强制类型转换
##### 2.5.2.1 基本介绍
自动类型转换的逆过程，将容量大的数据类型转换为容量小的数据类型。使用时要加上强制转换函数，但是可能会造成精度丢失
##### 2.5.2.2 使用细节
+ 当进行数据的从大类型向小类型的时候，需要使用强制类型转换
+ 强转符号只针对最近的操作数有效，往往会使用()来提升优先级
+ Char类型可以保存Int类型的常量值，但是不能保存Int的变量值，需要强转
+ Byte和Short类型在进行运算时，当做Int类型处理
### 2.6 值类型与String类型的转换
在程序开发中，经常需要将基本数据类型转成String类型，或者将String类型转成基本数据类型
#### 2.6.1 基本类型转String类型
语法:将基本类型的值+""即可
#### 2.6.2 String类型转基本数据类型
语法:通过基本类型的String的toXxx方法
#### 2.6.3 注意事项
在将String类型转成基本数据类型时，要确保String类型能够转成有效的数据

### 2.7标识符的命名规范
+ 首字符为字母，后续字符任意字母和数字、美元符号，可以后接下划线
+ 不可以数字开头
+ 首字符为操作符(比如 + - * /),后续字符也需要跟操作符，至少一个
+ 操作符(比如 + - * /)不能在标识符中间和最后
+ 用反引号包括的任何字符串，即使是关键字也可以
### 2.8. 关键字
package,import,class,object,trait,extends,with,type,forSome,private,protected,abstract,sealed,  
final,implicit,lazy,override,try,catch,finally,throw,if,else,match,case,do,while,for,return,yield,def,val,  
var,this,super,new,true,false,null

## 3.运算符
### 3.1 运算符介绍
运算符是一种特殊的符号，用以表示数据的运算、赋值和比较
+ 算术运算符
+ 赋值运算符
+ 比较运算符(关系运算符)
+ 逻辑运算符
+ 位运算符
### 3.2 算术运算符
#### 3.2.1 介绍
算术运算符是对数值类型的变量进行运算的
![算术运算符一览表](./images/7-算术运算符一览表.png)
#### 3.2.2 细节说明
+ 对于除号 "/",它的整数除和小数除是有区别的，整数之间做除法，只保留整数部分而舍弃小数部分
+ 当对一个数取模时，可以等价a%b = a-a/b*b
+ 注意:Scala中没有++、--操作符，需要通过+=、-=来实现同样的效果
### 3.3 关系运算符(比较运算符)
+ 关系运算符的结果是boolean型
+ 关系表达式经常用在if结构的条件中或循环结构的条件中
+ 关系运算符的使用和Java一样
+ 关系运算符一览表
![关系运算符一览表](./images/8-关系运算符一览表.png)
#### 3.3.1 细节说明
+ 关系运算符组成的表达式称为关系表达式
+ 比较运算符"=="不要误写成"="
+ 如果两个浮点数进行比较,应当保证数据类型一致
### 3.4 逻辑运算符
#### 3.4.1 逻辑运算符一览表
![逻辑运算符一览表](./images/9-逻辑运算符一览表.png)

### 3.5 赋值运算符
#### 3.5.1 赋值运算符的分类
![赋值运算符一览表](./images/10-赋值运算符.png)

#### 3.5.2 赋值运算符的特点
+ 运算顺序从右往左
+ 赋值运算符的左边只能是变量，右边可以是变量、表达式、常量值、字面量
+ 复合赋值运算符等价于如下效果:a+=3 <=> a=a+3

### 3.6 位运算符
#### 3.6.1 位运算符一览表
![位运算符一览表](./images/11-位运算符一览表.png)

### 3.7 运算符的特别说明
+ Scala不支持三目运算符，可以使用if-else的方式实现类似的功能

### 3.8 运算符的优先级
#### 3.8.1 运算符优先级一览表
![运算符优先级一览表](./images/12-运算符优先级一览表.png)
+ 运算符有不同的优先级，所谓优先级就是表达式运算中的运算顺序
+ 只有单目运算符、赋值运算符是从右向左运算的

## 4.程序流程控制
### 4.1 顺序控制
+ 程序从上到下逐行执行，中间没有任何判断和跳转
+ scala中定义变量时需要采用合法的前向引用

### 4.2 分支控制

### 4.3 switch分支结构

### 4.4 for循环控制
scala为for循环的这一常见的控制结构提供了非常多的特性，这些for循环的特定被称为for推导式或for表达式
#### 4.4.1 范围数据循环
+ 范围数据循环方式1
```go
for(i <- 1 to 3){
  println(i+" ")
}
```
注意使用to的话遍历的范围是[1,3]
+ 范围数据循环方式2
```go
for(i <- 1 until 3){
  println(i+" ")
}
```
注意使用until遍历的范围是[1,3)

#### 4.4.2 循环守卫
+ 基本案例
```go
for(i <- 1 to 3 if i!=2){
    println(i+" ")
}
```
循环守卫，即循环保护式(也称条件判断式，守卫)，保护式为true则进入循环体内部，为false则跳过，类似于continue  
上面的代码等价于下面的代码  
```go
for(i <- 1 to 3){
    if(1 != 2){
    println(i+" ")  
  }
}
```
#### 4.4.3 引入变量
+ 基本案例
```go
for(i <- 1 to 3; j = 4 -i){
    println(j+" ")
}
```
注意:没有关键字所以范围后一定要加分号来隔断逻辑  
上面的代码等价于下面的代码  
```go
for(i <- 1 to 3){
    val j = 4 - i
    println(j+" ")
}
```

#### 4.4.4 嵌套循环
+ 基本案例
```go
for(i <- 1 to 3;j <- 1 to 3){
    println("i="+i+" j="+j)
}
```
注意：没有关键字，所以范围后一定要加分号来隔断逻辑  
上面的代码等价于  
```go
for(i <- 1 to 3){
    for(j <- 1 to 3){
        println("i="+i+" j="+j)
    }
}
```
#### 4.4.5 循环返回值
+ 基本案例
```go
val res = for(i <- 1 to 10) yield i
println(res)
```
对案例的说明:将遍历过程中处理的结果返回到一个新的Vector集合中，使用yield关键字
#### 4.4.6 使用{}代替()
+ 基本案例
```go
for(i <- 1 to 3;j = i * 2){
    println("i ="+i+" j="+j)
}
```
上面的代码也可以写成下面这样  
```go
for{
    i <- 1 to 3
    j = i * 2
    println("i ="+i+" j="+j)
}
```
+ 对案例的基本说明  
{}和()对于for表达式来说都可以  
for 推导式有一个不成文的约定:当for推导式仅包含单一表达式时使用()，当其包含多个表达式时使用{}  
当使用{}来换行写表达式时，分号就不用写了
+ for循环步长控制
```go
for(i <- Range(1,3,2))

```

### 4.5 while循环控制
#### 4.5.1 基本语法
循环变量初始化
while(循环条件){
    循环体(语句)
    循环变量迭代
}
#### 4.5.2 注意事项和细节说明
+ 循环条件是返回一个布尔值的表达式
+ while循环是先判断再执行语句
+ 与if语句不同，while语句本身没有值，即整个while语句的结果是Unit类型的()
+ 因为while中没有返回值，所以当要用该语句来计算并返回结果时，就不可避免的使用变量，而变量需要声明在while循环的外部
，那么久等同于循环的内部对外部的变量造成了影响，所以不推荐使用，而是推荐使用for循环

### 4.6 do...while循环控制
#### 4.6.1 基本语法
循环变量初始化
do{
    循环体(语句)
    循环变量迭代
}while(循环条件)
#### 4.6.2 注意事项和细节说明
+ 循环条件是返回一个布尔值的表达式
+ 先执行再判断
+ 和while一样，因为do...while中没有返回值，所以当要用该语句来计算
并返回结果时，就不可避免的使用变量，而变量需要声明在do...while循环的外部，
那么就等同于循环的内部对外部的变量造成了影响，所以不推荐使用，而是推荐使用for循环
### 4.7多重循环控制
+ 将一个循环放在另一个循环体内，就形成了嵌套循环，其中for,while,do...while
均可以作为外层循环和内层循环
+ 实质上，嵌套循环是把内存循环当成外层循环的循环体。当只有内层循环的循环条件
为false时，才会完全跳出内层循环，才可结束外层的当次循环，开始下一次的循环
+ 设外层循环次数为m次，内层为n次，则内层循环体实际上需要执行m*n次

### 4.8 while循环的中断
#### 4.8.1 基本说明
scala内置控制结构特地去掉了break和continue,是为了更好的适应函数化编程推荐使用函数式的风格解决break和continue的
功能，而不是一个关键字
#### 4.8.2 案例演示
```scala
import util.control.Breaks._
var n = 10
breakable{
  while(n<=20){
    n+=1
    if(n==18){
      break()
    }
  }
  
}
println("n="+n)
```

#### 4.8.3 如何实现continue的效果
scala内置控制结构特地也去掉了continue,是为了更好地适应函数化编程，可以使用if-else或是循环守卫来实现continue的效果
+ 案例
```scala
for(i <- 1 to 10 if(i != 2 && i != 3 )){
  println("i="+i)
}
```

## 5.函数式编程基础
### 5.1 介绍
#### 5.1.1 概念说明
+ 在scala中，方法和函数几乎可以等同(比如他们的定义、使用、运行机制都一样)，只是函数的使用方式更加灵活
+ 函数式编程是从编程方式(范式)的角度来谈的，函数式编程把函数当做一等公民，充分利用函数、支持函数的多种使用方式，
比如函数是一等公民，像变量一样，既可以作为函数的参数使用，也可以将函数赋值给一个变量，函数的创建不用依赖于类或者对象，而在java中，
函数的创建则要依赖于类、抽象类或者接口
+ 面向对象编程是以对象为基础的编程方式
+ 在scala中函数式编程和面向对象编程融合在一起了

#### 5.1.2 函数式编程介绍
+ "函数式编程"是一种"编程范式"(programming paradigm)
+ "结构化编程"的一种，主要思想是把运算过程尽量协程一系列嵌套的函数调用
+ 函数式编程中，将函数也当做数据类型，因此可以接受函数当做输入(参数)和输出(返回值)
+ 函数式编程中，最重要的就是函数

### 5.2 函数的定义
#### 5.2.1 基本语法
def 函数名([参数名:参数类型],...)[[:返回值类型]=]{
    语句...
    return 返回值
}
+ 函数声明关键字为def(definition)
+ [参数名:参数类型],...:表示函数的输入(参数列表)可以没有，如果有，多个参数使用逗号间隔
+ 函数中的语句:表示为了实现某一个功能的代码块
+ 函数可以有返回值也可以没有
+ 返回值形式1: :返回值类型 =
+ 返回值类型2: = 表示返回值类型不确定，使用类型推导完成
+ 返回值形式3: 表示没有返回值，return 不生效
+ 如果没有return,默认以执行到最后一行的结果作为返回值

#### 5.2.2 函数递归调用
一个函数在函数体内又调用了本身，称为递归调用  
需要遵守的重要原则:  
+ 程序执行一个函数时，就创建一个新的受保护的独立空间(新函数栈)
+ 函数的局部变量是独立的，不会相互影响
+ 递归必须向退出递归的条件逼近，否则就是无限递归
+ 当一个函数执行完毕，或者遇到return就会返回，遵守谁调用，就将结果返回给谁
### 5.3 函数的注意事项和细节讨论
+ 函数的形参列表可以是多个，如果函数没有形参，调用时可以不带()
+ 形参列表和返回值列表的数据类型可以是值类型和引用类型
+ scala中的函数可以根据函数体最后一行代码自行推断函数返回值类型，那么在这种情况下，return关键字可以省略
![省略return](./images/13-省略retrurn.png)
+ 因为scala可以自行推断，所以在省略return关键字的场合，返回值类型也可以省略
+ 如果函数明确使用return关键字，那么函数返回就不能使用自行推断了，这时要明确写成:返回类型=，当然如果什么都不写，即使有return返回值为()
+ 如果函数明确声明无返回值(声明Unit),那么函数体中即使使用return关键字也不会有返回值
+ 如果明确函数无返回值或不确定返回值类型，那么返回值类型可以省略(或声明为Any)
+ scala语法中任何的语法结构都可以嵌套其他语法结构，即:函数中可以再声明/定义函数，类中可以再声明类，方法中可以再声明/定义方法
+ scala函数的形参，在声明参数时，直接赋初始值(默认值),这时调用函数时如果没有指定实参，则会使用默认值。如果指定了实参，则实参会覆盖默认值
+ 如果函数存在多个参数，每一个参数都可以设定默认值，那么这个时候，传递的参数到底是覆盖默认值还是赋值给没有默认值的参数，就不确定了(默认按照声明顺序[从左到右])，在这种情况下，可以采用带名参数
+ scala函数的形参默认是val的，因此不能在函数中进行修改
+ 递归函数未执行之前无法判断结果类型，在使用时必须有明确的返回值类型
+ scala函数支持可变参数
```scala
//支持0到多个参数
def sum(args:Int*):Int={

}
//支持1到多个参数
def sum(n1:Int,args:Int*):Int={

}
```
**说明:**  
(1).args是集合，通过for循环可以访问到各个值
(2).可变参数需要写在形参列表的最后
### 5.4 过程
#### 5.4.1 基本介绍
将函数的返回类型为Unit的函数称之为过程(procedure),如果明确函数没有返回值，那么等号可以省略
#### 5.4.2 案例说明
```scala
//f10没有返回值，可以使用Unit来说明
//这时，这个函数我们也叫过程
def f10(name:String):Unit={
  println(name+"hello ")
}
```
#### 5.4.3 注意事项和细节说明
+ 注意区分:如果函数声明时没有返回值类型，但是有=号，可以进行类型推断最后一行代码。这时这个函数实际是有返回值的，该函数并不是过程
### 5.5 惰性函数
#### 5.5.1 介绍
当函数返回值被声明为lazy时，函数的执行将被推迟，直到我们首次对此取值，该函数才会执行。这种函数我们称之为惰性函数
#### 5.5.2 注意事项和细节
+ lazy不能修饰var类型的变量
+ 不但是在调用函数时加了lazy会导致函数的执行被推迟，在声明一个变量时如果加了lazy,变量值的分配也会推迟
### 5.5 异常
#### 5.5.1 介绍
scala提供try和catch块来处理异常。try块用于包含可能出错的代码，catch块用于处理try块中发生的异常。可以根据需要在程序中有任意数量的try...catch块。
#### 5.5.2 异常处理小结
+ 可以将可疑代码放到try块中，在try块之后使用了一个catch处理程序来捕获异常。如果发生任何异常,catch处理程序将处理它,程序将不会异常终止
+ scala的异常的工作机制和Java一样，但是scala没有"checked(编译期)"异常，即scala没有编译异常这个概念，异常都是在运行的时候捕获处理
+ 用throw关键字抛出一个异常对象。所有异常都是Throwable的子类型，throw表达式是有类型的，就是Nothing,因为Nothing是所有类型的子类型，所以
throw表达式可以用在需要类型的地方
+ 在scala里借用了模式匹配的思想来做异常匹配，因此在catch的代码里是一系列case子句来匹配异常，当匹配上后=> 有多条语句可以换行写
+ 异常捕捉的机制和其他语言中一样，如果有异常发生，catch子句是按次序捕捉的，因此，在catch子句中，越具体的异常越要靠前，越普遍的异常越靠后，
如果把越普遍的异常写在前，把具体的异常写在后，在scala中也不会报错，但这样是非常不好的编程风格
+ finally 子句用于执行不管是正常处理还是异常发生时都需要执行的步骤，一般用于对象的清理工作，这点和java一样
+ scala提供了throws关键字来声明异常。可以使用方法定义声明异常，它向调用者函数提供了此方法可能引发此异常的信息。有助于调用函数处理并将该
代码包含在try-catch块中，以避免程序异常终止，在scala中可以使用throws注解来声明异常

  
