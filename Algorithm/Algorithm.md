# 算法相关技术总结
## 1. hash算法
### 1.1 murmurhash
https://github.com/spaolacci/murmur3



# 2. 排序算法

## 2.1 选择排序

### 2.1.1 算法原理

遍历一遍待排序元素，找出最小元素与第一个位置的元素进行交换

遍历第2~N个元素，找出这些元素中的最小元素与第二个位置的元素进行交换

...



### 2.1.2 算法实现

![image-20210401103058315](images/image-20210401103058315.png)



其中交换一个数组中两个位置的值也可以按照如下方法实现

![image-20210401103539896](images/image-20210401103539896.png)



### 2.1.3 复杂度分析

时间复杂度是O(N^2)

空间复杂度O(1)

## 2.2 冒泡排序

### 2.2.1 算法原理

相邻两个元素比较大小，如果逆序，则交换





### 2.2.2 算法实现

![image-20210401103625268](images/image-20210401103625268.png)

### 2.2.3 复杂度分析

时间复杂度O(N^2)



## 2.3 插入排序

### 2.3.1 算法原理



### 2.3.2 算法实现

![image-20210401114416329](images/image-20210401114416329.png)



### 2.3.3 复杂度分析

时间复杂度O(N^2),额外空间复杂度O(1)





## 2.4 归并排序

### 2.4.1 算法原理

整体就是一个简单递归，左边排好序，右边排好序，让其整体有序

让其整体有序的过程用了外排序方法

利用master公式来求解时间复杂度



### 2.4.2 算法实现

![image-20210401144608415](images/image-20210401144608415.png)

### 2.4.3 复杂度分析

时间复杂度O(N*logN)

空间复杂度O(N)



## 2.5 快速排序

### 2.5.1 算法原理





### 2.5.2 算法实现

![image-20210401164744569](images/image-20210401164744569.png)

### 2.5.3 复杂度分析

时间复杂度：O(N*logN)

空间复杂度：O(logN)





## 2.6 排序算法汇总

![image-20210401193554056](images/image-20210401193554056.png)

![image-20210401194627800](images/image-20210401194627800.png)

![image-20210401194913092](images/image-20210401194913092.png)



# 3. 异或相关

## 3.1 异或的性质

+ 0^N=N

  0和任意数N异或，结果都是任意数N

+ N^N=0

  自己和自己异或，结果是0

+ 满足交换律和结合律

  a^b=b^b(交换律)

  a^b^c=a^(b^c)(结合律)

## 3.2 异或的应用

### 3.2.1 不使用第三个变量，交换两个数

```java
a=a^b;
b=a^b;
a=a^b
```

可以像上面这样交换两个数的前提是变量a和变量b在内存中是两块独立的空间



### 3.2.2 找出出现指定次数的数

在一组数中，只有一种数出现了奇数次，其余的都出现了偶数次，怎么找出出现奇数次的数

**解答：**

准备一个初始变量int eor=0

让eor挨个与数组中的所有数进行异或操作，结果赋值给eor,最终eor的值就是出现奇数次的数



在一个数组中，已知有两种数出现了奇数次，其他所有的数都出现了偶数次，怎么找出这两种数

要求时间复杂度是O(N)

**解答：**

准备一个初始变量int eor=0

让eor挨个与数组中的所有数进行异或操作，结果赋值给eor，然后再准备一个变量eor2,假设eor的第8位二进制为1，那么让eor2与数组中第8位是1的数进行异或运算，并将结果赋值给eor2,那么最终eor2的值就是a或者b，假设是a,然后b就可以通过eor和eor2进行异或就可以得到

![image-20210401113349096](images/image-20210401113349096.png)





# 4.二分法

## 4.1 在一个有序数组中，找某个数首是否存在



## 4.2 在一个有序数组中，找大于等于某个数最左侧的位置



## 4.3 局部最小值问题

题目:在一个无序数组中，任何相邻的两个数不相等

局部最小的定义:

对于0位置来说，如果0位置的数小于1位置的数，那么0位置的数就是局部最小

对于N-1位置来说，如果N-1位置的数小于N-2位置的数，那么N-1位置的数就是局部最小

对于中间位置i来说，如果i位置的数既小于i-1位置的数，又小于i+1位置的数，那么i位置的数就是局部最小



# 5. 对数器

![image-20210401125051933](images/image-20210401125051933.png)



# 6. master公式

![image-20210401142911928](images/image-20210401142911928.png)



# 7. 荷兰国旗问题

![image-20210401153507299](images/image-20210401153507299.png)





# 8.堆

![image-20210401170118719](images/image-20210401170118719.png)

## 8.1 堆排序题目

![image-20210401175326153](images/image-20210401175326153.png)



# 9.哈希表

![image-20210401200235001](images/image-20210401200235001.png)



# 10. 有序表

![image-20210401200430292](images/image-20210401200430292.png)

注意6、7条是放入有序表的东西  是有序表而不是哈希表



# 11. 单链表和双链表

![image-20210401201055333](images/image-20210401201055333.png)



# 12. 二叉树的遍历

## 12.1 先序遍历

先序遍历就是二叉树的深度遍历

### 12.1.1 非递归实现

![image-20210402082631956](images/image-20210402082631956.png)



## 12.2 中序遍历



### 12.2.1 非递归实现

![image-20210402083645590](images/image-20210402083645590.png)





## 12.3 后序遍历

### 12.3.1 非递归实现

![image-20210402083006414](images/image-20210402083006414.png)



## 12.4 宽度遍历

![image-20210402084614858](images/image-20210402084614858.png)

求一个树的最大宽度

![image-20210402085540783](images/image-20210402085540783.png)

![image-20210402085601602](images/image-20210402085601602.png)



# 13. 搜索二叉树

搜索二叉树：左子树上的数都比根节点元素小，右子树上的数都比根节点元素大

判断一棵树是否是搜索二叉树

![image-20210402091555659](images/image-20210402091555659.png)

另外一种实现方式

![image-20210402091854158](images/image-20210402091854158.png)

非递归方式

![image-20210402092023067](images/image-20210402092023067.png)



# 14. 完全二叉树

完全二叉树的学术定义：

如何判断一个树是完全二叉树

对树进行宽度遍历(先序遍历)

1. 任意一个节点，有右子树没有左子树直接返回false
2. 在不违反1条件下，如果遇到了第一个左右子树不全的数，后续节点必须都是叶节点，否则返回false

![image-20210402093003977](images/image-20210402093003977.png)

![image-20210402093109604](images/image-20210402093109604.png)



# 15. 平衡二叉树

对于任何一个子树，左树的高度和右树的高度差值不超过1

如何判断一个树是平衡二叉树

![image-20210402094755916](images/image-20210402094755916.png)



# 16.满二叉树

判断一个树是否是满二叉树

![image-20210402100940305](images/image-20210402100940305.png)‘

# 17. 最低公共祖先节点

给定两个二叉树的节点node1和node2,找到它们的最低公共祖先节点

![image-20210402101955506](images/image-20210402101955506.png)



# 18. 求后继节点

![image-20210402103927641](images/image-20210402103927641.png)



# 19. 折纸问题

![image-20210402105412617](images/image-20210402105412617.png)



#  20. 图

##  20.1 图的存储方式

+ 邻接表
+ 邻接矩阵

![image-20210402112622783](images/image-20210402112622783.png)

深度优先遍历

![image-20210402132724701](images/image-20210402132724701.png)

## 20.2 拓扑排序算法

适用范围：要求有向图，且有入度为0的节点，且没有环

![image-20210402133213927](images/image-20210402133213927.png)

## 20.3 kruskal算法

适用范围：要求无向图

![image-20210402135043900](images/image-20210402135043900.png)



## 20.4 prim算法

适用范围：要求无向图



## 20.5 Dijkstra算法

适用范围：没有权值为负数的边





# 21. 贪心算法

![image-20210402152105938](images/image-20210402152105938.png)



![image-20210402160832974](images/image-20210402160832974.png)

利用小根堆

![image-20210402160803769](images/image-20210402160803769.png)





![image-20210402161128142](images/image-20210402161128142.png)





# 22. 补充

## 22.1 打印一个字符串的全部子序列，包括空字符串





![image-20210402181425167](images/image-20210402181425167.png)



![image-20210402183059365](images/image-20210402183059365.png)

![image-20210402183825780](images/image-20210402183825780.png)



![image-20210402183927319](images/image-20210402183927319.png)



![image-20210402184346181](images/image-20210402184346181.png)



![image-20210402184430414](images/image-20210402184430414.png)

![image-20210402185310462](images/image-20210402185310462.png)



![image-20210402185645968](images/image-20210402185645968.png)

![image-20210402190131189](images/image-20210402190131189.png)

另外一个更优秀的实现

![image-20210402190230067](images/image-20210402190230067.png)



![image-20210403082414657](images/image-20210403082414657.png)

![image-20210403083330504](images/image-20210403083330504.png)

![image-20210403083358685](images/image-20210403083358685.png)

# 23. 布隆过滤器

![image-20210403090139158](images/image-20210403090139158.png)

![image-20210403090213263](images/image-20210403090213263.png)

![image-20210403090328628](images/image-20210403090328628.png)



# 24. 一致性哈希原理



# 25.并查集

![image-20210403092458901](images/image-20210403092458901.png)



# 26.KMP

解决str2是否是str1的子串问题

![image-20210403112946056](images/image-20210403112946056.png)

![image-20210403114501477](images/image-20210403114501477.png)



# 27. Manacher算法

解决字符串str中，最长回文子串的长度类问题



![image-20210403135300932](images/image-20210403135300932.png)

使用双端队列

![image-20210403141328611](images/image-20210403141328611.png)

# 28. 单调栈

![image-20210403142906527](images/image-20210403142906527.png)



# 29. 树形DP套路

![image-20210403144753329](images/image-20210403144753329.png)

![image-20210403150156681](images/image-20210403150156681.png)







![image-20210403144840100](images/image-20210403144840100.png)

![image-20210403145931480](images/image-20210403145931480.png)





![image-20210403150233081](images/image-20210403150233081.png)

![image-20210403151023767](images/image-20210403151023767.png)





#  30. Morris遍历

![image-20210403151126053](images/image-20210403151126053.png)

![image-20210403151214042](images/image-20210403151214042.png)



![image-20210403161408034](images/image-20210403161408034.png)

先序遍历

![image-20210403162440736](images/image-20210403162440736.png)



中序遍历

![image-20210403163109983](images/image-20210403163109983.png)



# 31.大数据题目解题技巧

![image-20210403165313332](images/image-20210403165313332.png)



![image-20210403165533140](images/image-20210403165533140.png)

![image-20210403171959152](images/image-20210403171959152.png)



![image-20210403173019772](images/image-20210403173019772.png)

# 32. 位运算

![image-20210403174453133](images/image-20210403174453133.png)

![image-20210403180307193](images/image-20210403180307193.png)

下面的方法考虑的ab可能溢出的问题

![image-20210403180403729](images/image-20210403180403729.png)



![image-20210403180822599](images/image-20210403180822599.png)

![image-20210403181813023](images/image-20210403181813023.png)



![image-20210403181830330](images/image-20210403181830330.png)

![image-20210403182450652](images/image-20210403182450652.png)

加法：



![image-20210403183059499](images/image-20210403183059499.png)

减法：

![image-20210403183301047](images/image-20210403183301047.png)

乘法：

![image-20210403183608049](images/image-20210403183608049.png)

除法

![image-20210403184807428](images/image-20210403184807428.png)



# 33. 动态规划

机器人走步

![image-20210403202052184](images/image-20210403202052184.png)

![image-20210403203459464](images/image-20210403203459464.png)



硬币问题

![image-20210403210105546](images/image-20210403210105546.png)

![image-20210403212528482](images/image-20210403212528482.png)



![image-20210404075135778](images/image-20210404075135778.png)

![image-20210404075144974](images/image-20210404075144974.png)

硬币找零问题

![image-20210404082321857](images/image-20210404082321857.png)

![image-20210404083828905](images/image-20210404083828905.png)

![image-20210404085200211](images/image-20210404085200211.png)



# 34. 有序表

![image-20210404090627382](images/image-20210404090627382.png)

红黑树、AVL树、Size-balanced树、跳表都可以实现有序表

![image-20210404094605628](images/image-20210404094605628.png)

红黑树的特点：

+  头节点和叶节点必须是黑色
+ 红节点不相邻
+ 对于任何一棵子树，从某一个头部cur出发，到其叶节点的每一条路径的黑节点数量相同



# 35. 刷题技巧

## 35.1 xxx

![image-20210404104511716](images/image-20210404104511716.png)

思路分析：

数轴上每个点作为绳子最右侧端点的情况下，能够覆盖几个点，每个点都这么求，最多覆盖点的情况一定在其中

还有更优秀的解法



![image-20210404105728036](images/image-20210404105728036.png)

普通解法

![image-20210404110553867](images/image-20210404110553867.png)

![image-20210404110644262](images/image-20210404110644262.png)



![image-20210404112724256](images/image-20210404112724256.png)



![image-20210404112912329](images/image-20210404112912329.png)



![image-20210404114340987](images/image-20210404114340987.png)



![image-20210404120010714](images/image-20210404120010714.png)



![image-20210404120420895](images/image-20210404120420895.png)



![image-20210404121102969](images/image-20210404121102969.png)

![image-20210404121547179](images/image-20210404121547179.png)



![image-20210404121733645](images/image-20210404121733645.png)

用Hash表

![image-20210404122003885](images/image-20210404122003885.png)

![image-20210404123917732](images/image-20210404123917732.png)



![image-20210404124007274](images/image-20210404124007274.png)

定义一个int 类型的count变量，遇到 `(` count++，遇到`)` count--,在这个过程中count达到的最大值就是其深度



另外一个题目：

给定一个由`(` 和 `)`组成的字符串，请找到最长的有效括号子串





![image-20210404133820199](images/image-20210404133820199.png)



![image-20210404134246881](images/image-20210404134246881.png)



![image-20210404134337634](images/image-20210404134337634.png)

![image-20210404134721740](images/image-20210404134721740.png)

![image-20210404135309634](images/image-20210404135309634.png)

![image-20210404135432958](images/image-20210404135432958.png)

![image-20210404140001819](images/image-20210404140001819.png)

![image-20210404140230572](images/image-20210404140230572.png)

![image-20210404140412138](images/image-20210404140412138.png)

![image-20210404140627688](images/image-20210404140627688.png)



![image-20210404141038263](images/image-20210404141038263.png)

这道题目跟leetcode上洗衣机的那道题目类似

![image-20210404142120313](images/image-20210404142120313.png)





![image-20210404142528923](images/image-20210404142528923.png)

![image-20210404142607218](images/image-20210404142607218.png)



![image-20210404142933488](images/image-20210404142933488.png)

![image-20210404143027165](images/image-20210404143027165.png)

![image-20210404143412449](images/image-20210404143412449.png)

![image-20210404143440901](images/image-20210404143440901.png)

![image-20210404143501527](images/image-20210404143501527.png)

![image-20210404144618952](images/image-20210404144618952.png)

![image-20210404144724620](images/image-20210404144724620.png)

![image-20210404144747891](images/image-20210404144747891.png)

![image-20210404145134145](images/image-20210404145134145.png)

![image-20210404162234463](images/image-20210404162234463.png)

![image-20210404162300250](images/image-20210404162300250.png)

![image-20210404162436799](images/image-20210404162436799.png)

把n的所有质数因子找出来累加然后减去质数因子的个数就是结果

![image-20210404163649303](images/image-20210404163649303.png)



![image-20210404163819343](images/image-20210404163819343.png)



![image-20210404170850617](images/image-20210404170850617.png)

![image-20210404171013111](images/image-20210404171013111.png)

![image-20210404171426554](images/image-20210404171426554.png)

![image-20210404172124594](images/image-20210404172124594.png)

![image-20210404173549122](images/image-20210404173549122.png)

![image-20210404173739107](images/image-20210404173739107.png)

![image-20210404174222222](images/image-20210404174222222.png)



![image-20210404174822764](images/image-20210404174822764.png)

![image-20210404175313423](images/image-20210404175313423.png)

![image-20210404175344227](images/image-20210404175344227.png)



![image-20210404183135319](images/image-20210404183135319.png)



![image-20210404183401779](images/image-20210404183401779.png)

![image-20210404193614521](images/image-20210404193614521.png)

斐波那契数列问题

![image-20210404194506633](images/image-20210404194506633.png)

![image-20210404194957200](images/image-20210404194957200.png)



