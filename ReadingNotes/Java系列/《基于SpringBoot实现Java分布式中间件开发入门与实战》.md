[TOC]

# 1. 书籍信息

书名:基于Spring Boot实现Java分布式中间件开发入门与实战

作者:钟林森

封面：

<img src="images/image-20210530095751879.png" alt="image-20210530095751879" style="zoom: 25%;" />

<img src="images/image-20210530095814408.png" alt="image-20210530095814408" style="zoom:25%;" />

学习时间：2021-05-23~2021-05-29

总结整理时间：2021-05-30

# 2. 缓存中间件Redis

## 2.1 典型应用场景

### 2.1.1 热点数据的存储与展示

“热点数据”可以理解为大部分用户频繁访问的数据，对于所有的用户来说，访问热点数据将得到同一个结果。如微博热搜，大多用户在同一时刻搜索的内容是一样的，如果采用传统的查询数据库的方法获取热点数据，那将大大地增加数据库的压力，降低数据库的读写性能。

### 2.1.2最近访问的数据

用户最近访问过的数据记录在数据库中将采用“日期字段”作为标识，频繁查询的实现时采用该日期字段与当前时间做“时间差”的比较查询，这种方式是相当耗时的。而采用Redis的List作为“最近访问的足迹”的数据类型，将大大减少数据库的查询请求次数

### 2.1.3 并发访问

对于高并发访问某些数据的情况，Redis可以将这些数据预先装载在缓存中，每次出现高并发的请求则可以直接从缓存中获取相应数据，减少高并发访问给数据库带来的压力。

### 2.1.4 排行榜

采用Redis的有序集合(Sorted Set)可以很好地实现用户的排名，可避免传统的基于数据库的Order By以及Group By关键字查询带来的性能问题。



## 2.2 缓存穿透及解决方案

## 2.2.1 什么是缓存穿透？

概括来讲:大量的key没用命中缓存直接访问数据库

### 2.2.2 解决方案

对于前端而恶意请求，当查询数据库时如果没有查询到数据，则将Null返回给前端用户，同时将该Null数据写入缓存，并对对应的Key设置一定的过期时间。



## 2.3 缓存雪崩及解决方案

### 2.3.1 什么是缓存雪崩？

在某个时间点，缓存中的key集体过期失效，致使大量查询数据的请求都落在了数据库上，导致数据库负载过高，压力暴增，甚至有可能压垮数据库。

### 2.3.2 解决方案

这种问题产生的原因主要是大量的Key在某个时间点或者某个时间段过期失效，所以为了更好地避免这种情况的方法，一般的做法是为这些key设置不同的、随机的TTL,从而错开缓存中key的失效时间点，可以在某种程度上减轻数据库的查询压力。



## 2.4 缓存击穿及解决方案

### 2.4.1 什么是缓存击穿？

缓存中某个频繁被访问的key(可以称为“热点key”)，在不停地扛着前端的高并发请求，当这个key突然在某个瞬间过期失效，持续的高并发访问请求就穿破缓存，直接访问数据库，导致数据库压力在某一瞬间暴增，这种现象就像是“在一张薄膜纸上造出了一个洞”



### 2.4.2 解决方案

这种问题产生的原因其实主要是热点的key过期失效了。在实际情况下，既然这个key可以被当做“热点”频繁访问，那么就应该设置这个key永不过期，这样前端的高并发请求将几乎永远不会落在数据库上。



# 3. 抢红包系统红包随机金额生成算法(二倍均值法)

## 3.1 二倍均值算法核心思想

根据每次剩余的总金额M和剩余人数N，执行`(M/N)*2`的操作得到一个边界值E，然后制定一个从0到E的随机区间，在这个随机区间内将产生一个随机金额R，此时总金额M将更新为M-R,剩余人数N更新为N-1，在继续重复上述的执行流程。以此类推，直至最终剩余人数N-1为0，即代表随机数已经产生完毕。



## 3.2 代码实现

```java
public class RedPacketUtil {
    /**
     * 发红包算法，金额参数以分为单位
     *
     * @param totalAmount    红包总金额(单位为分)
     * @param totalPeopleNum 总人数
     * @return 包含有各个随机金额的List对象
     */
    public static List<Integer> divideRedPackage(Integer totalAmount, Integer totalPeopleNum) {
        //用于存储每次产生的小红包随机金额列表，金额单位为分
        List<Integer> amountList = new ArrayList<Integer>();
        //判断总金额和总人数参数的合法性
        if (totalAmount > 0 && totalPeopleNum > 0) {
            //记录剩余的总金额，初始化时即为红包的总金额
            int restAmount = totalAmount;
            //记录剩余的总人数，初始化时即为指定的总人数
            int restPeopleNum = totalPeopleNum;
            //定义产生随机数的实例对象
            Random random = new Random();
            //不断循环遍历、迭代更新产生随机金额，直到N-1≤0
            for (int i = 0; i < totalPeopleNum - 1; i++) {
                // 随机范围：[1，剩余人均金额的两倍)，左闭右开
                //amount即为产生的随机金额R，单位为分
                int amount = random.nextInt(restAmount / restPeopleNum * 2 - 1) + 1;
                //更新剩余的总金额M=M-R
                restAmount -= amount;
                //更新剩余的总人数N=N-1
                restPeopleNum--;
                //将产生的随机金额添加进列表
                amountList.add(amount);
            }
            //循环完毕，剩余的金额即为最后一个随机金额，也需要将其添加进列表中
            amountList.add(restAmount);
        }
        //将最终产生的随机金额列表返回
        return amountList;
    }
}
```



# 4. 高并发压测工具

## 4.1 Apache JMeter

Apache JMeter是Apache组织开发的基于Java的压力测试工具，可以通过产生来自不同类别的压力，模式实际生产环境中高并发产生的巨大负载，从而对应用服务器、网络或对象整体性能进行测试。



# 5.消息队列的典型应用场景

## 5.1 异步通信和服务解耦

将原先“一条线走到底”的业务逻辑进行解耦

## 5.2 接口限流和消息分发

### 5.2.1 接口限流

前端产生的高并发请求并不会像“无头苍蝇”一样立即到达后端系统接口，而是像每天上班时的地铁限流一样，将这些请求按照“先来后到”的顺序存入RabbitMQ的队列，即在某种程度上实现“接口限流”

### 5.2.2 消息异步分发

当商品库存充足时，当前抢购的用户将可以抢到该商品，之后会异步地通过发送短信、发送邮件等方式通知用户抢购成功，并告知用户尽快付款，即在某种程度上实现了“消息异步分发”

## 5.3 延迟处理

1. 成功抢到票后30分钟内未付款的处理
2. 商城购物时“点击‘去付款’”而迟迟没有在规定的时间内支付的处理
3. 点外卖时下单成功后迟迟没有在规定的时间内付款的处理

上述场景传统的解决思路是使用定时器，性能较好的处理方式是使用RabbitMQ的延迟队列进行处理。



# 6. 分布式锁

## 6.1 对分布式锁的要求

### 6.1.1 排他性

需要保证在分布式部署、服务集群部署的环境下，被共享的资源(如数据或者代码块)在同一时间只能被一台服务器上的一个线程访问

### 6.1.2 避免死锁

当前线程获取锁之后，经过一段有限的时间(该时间一般用于执行实际的业务逻辑)，一定要释放锁(正常情况或者异常情况下释放)

### 6.1.3 高可用

获取或释放锁的机制必须高可用而且性能极佳

### 6.1.4 可重入

当前机器的当前线程在彼时如果没有获取该锁，那么在等待一定的时间后一定要保证可以获取该锁。

### 6.1.5 公平锁

非硬性要求

不同服务器的不同线程获取锁的概率最好保证是一样的



## 6.2 实现分布式锁的方案

### 6.2.1 基于数据库级别的

1. 乐观锁

   在查询、操作共享数据记录时带上一个标识字段“版本号(version)”,通过version来控制每次对数据记录执行的更新操作

2. 悲观锁

   以MySQL的InnoDB为例，主要是通过在访问共享的数据记录时加上`For Update`关键字，表示该共享的数据记录已经被当前线程锁住了(行级别锁、表级别锁)，只有当该线程操作完成并提交事务之后，才会释放该锁，从而其他线程才能访问该数据记录

**乐观锁和悲观锁的对比：**

这两种实现方式除了代码层面上的不同，在应用性能和数据库性能层面也是迥然不同的。

1. 对于乐观锁而言，由于其采用版本号(version)的机制实现，故而在高并发产生多线程时，同一时刻将只有一个线程能获取“锁”，并成功操作共享资源，而其他线程将获取失败，而且是永久性的失败。从这个角度看，这种方式虽然可以控制并发线程对共享资源的访问，但是却牺牲了系统的吞吐性能。由于乐观锁主要是通过version字段对共享数据进行跟踪和控制，其最终的一个实现步骤是带上version进行匹配、同时执行version+1的更新操作，故而当并发的多线程需要频繁“写”数据库时，是会严重影响数据库性能的。从这个角度看，“乐观锁”比较适合“写少读多”的业务场景
2. 对于悲观锁而言，由于其实建立在数据库底层搜索引擎的基础之上，并使用`select ... for update`的查询语句对共享资源加锁，故而当产生高并发多线程情趣，特别是“读”请求时，将对数据库的性能带来严重的影响。因为在同一时刻产生的多线程中将只有一个线程能获取锁，而其他的线程敬处于阻塞的状态，直到该线程释放了锁。“悲观锁”的方式如果使用不当，将会产生“死锁”的现象(即两个或者多个线程同时处于等待获取对方的资源的锁的状态)，故而“悲观锁”更适用于“读少写多”的业务场景

### 6.2.2 基于Redis的原子操作

主要通过`setnx`和`expire`原子操作，`setnx`表示只有当key在Redis不存在时才能设置成功，通常这个key需要设置为与共享的资源有联系，用于间接的当做“锁”，并采用`expire`操作释放获取的锁。

### 6.2.3 基于Zookeeper的互斥排他锁

主要是通过创建有序节点+Watcher机制

通过Zookeeper在指定的标识字符串(通常这个标识符字符串需要设置为与共享资源有联系，即可以间接地当做“锁”)下维护一个临时有序的节点列表Node List,并保证同一时刻并发线程访问共享资源时只能有一个最小序号的节点(即代表获取到锁的线程)，该节点对应的线程即可执行访问共享资源的操作



### 6.2.4 基于开源框架Redisson的分布式锁





# 7. Zookeeper

## 7.1 作用

### 7.1.1 统一配置管理

将每个子系统都需要配置的文件统一放置到Zookeeper的ZNode节点中

### 7.1.2 统一命名服务

通过给存放在ZNode上的资源进行统一命名，各个子系统便可通过名字获取到节点上相应的资源

### 7.1.3 分布式锁

通过创建与该共享资源相关的“顺序临时节点”与“动态Watcher监听机制”，从而控制多线程对共享资源的并发访问

### 7.1.4 集群状态

通过动态地感知节点的增加、删除，从而保证集群下的相关节点数据主、副本数据的一致。



# 8. 综合中间件Redisson

## 8.1 概述

Redisson是一款免费开源的中间件，内置了一系列的分布式对象、分布式集合、分布式锁以及分布式服务等诸多功能特性，是一款基于Redis实现的、拥有一系列分布式系统功能特性的工具包，可以说是实现分布式系统架构中缓存中间件的最佳选择。



## 8.2 典型应用场景

### 8.2.1 去重

Redisson的“布隆过滤器”是需要将当前的元素经过事先设计构建好的K个哈希函数计算出K个哈希值，并将预先已经构建好的“位数组”的相关下标取值置为1。当某个元素需要判断是否已经存在时，则同样是先经过K个哈希函数求取K个哈希值，并判断“位数组”相应的k个下标的取值是否都为1。如果是，则代表元素是“大概率”存在的，否则该元素一定不存在。



对于布隆过滤器而言，其优点与缺点是并存的。有点在于它不需要开辟额外的内存存储元素，从而节省了存储空间。缺点在于判断元素是否在集合中时，是有一定的误判率的；此外，添加进布隆过滤器的元素是无法删除的，因为位数组的下标是多个元素共享的，如果删除的话，很有可能出现误删的情况。



### 8.2.2 分布式锁 

Redisson之所以提供了“分布式锁”这一功能组件，最大的原因在于基于Redis的原子操作实现的分布式锁是有一定的缺陷的，而Redisson的分布式锁可以很好的弥补这些缺陷。这些缺陷包括以下几点：

1. 执行Redis的原子操作`expire`时，需要设置key的过期时间TTL,不同的业务场景设置的TTL是不同的，如果设置不当，向很有可能影响应用系统和Redis服务的性能。
2. 采用Redis的原子操作`setnx`获取分布式锁时，不具备“可重入”的特性。即当高并发产生多线程时，同一时刻只有一个线程可以获取锁，从而操作共享资源；而其他的线程将获取锁失败，并且是永远失败。而有一些业务场景要求线程具有“可重入”特性，则需要在应用程序里添加`while(true){}`的代码块，即不断地循环等待获取分布式锁，这种方式很明显既不"优雅"，又很有可能造成系统卡顿的现象。
3. 在执行Redis的原子操作`setnx`之后，`expire`之前，如果Redis的服务节点发生宕机，由于锁没有及时被释放而导致最终很有肯能出现“死锁”的现象，即永远不会有其他的线程获取锁(因为锁没有被删除，导致其永久存在)

Redisson提供的分布式锁的分类：

1. 可重入锁(Reentrant Lock)
2. 公平锁(Fair Lock)
3. 联锁(MultiLock)
4. 红锁(RedLock)
5. 读写锁(ReadWriteLock)
6. 信号量(Semaphore)
7. 闭锁(CountDownLatch)



















































